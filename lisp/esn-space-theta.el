;;; esn-space-theta.el --- Spacing routines for THETA/OMEGA/SIGMA blocks
;; 
;; Filename: esn-space-theta.el
;; Description: 
;; Author: Matthew L. Fidler
;; Maintainer: 
;; Created: Thu Apr 22 12:17:11 2010 (-0500)
;; Version: 
;; Last-Updated: Mon May  2 14:06:13 2011 (-0500)
;;           By: Matthew L. Fidler
;;     Update #: 31
;; URL: 
;; Keywords: 
;; Compatibility: 
;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 
;;; Commentary: 
;; 
;; 
;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 
;;; Change log:
;; 08-Sep-2010    Matthew L. Fidler  
;;    Last-Updated: Wed Sep  8 09:49:55 2010 (-0500) #27 (Matthew L. Fidler)
;;    Took out dependence on esn-wfn-model-records
;; 27-Aug-2010    Matthew L. Fidler  
;;    Last-Updated: Fri Aug 27 14:05:49 2010 (-0500) #21 (Matthew L. Fidler)
;;    I'm unsure if this routine is still used....
;; 
;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 3, or
;; (at your option) any later version.
;; 
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;; 
;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 
;;; Code:

(declare-function esn-get-variable-names "esn-extended")
(declare-function esn-error "esn-exec")
(declare-function esn-narrow-rec "esn-narrow")
(require 'esn-start)
(defun esn-get-error-type-from-str (str &optional var repEta e1)
  "Gets the Error Type from a string."
  (let* (
	 (case-fold-search 't)
	 (evar (regexp-opt (esn-get-variable-names "OME")))
        (err "?")
	(eta (format "\\(%s([0-9]+)\\|%s\\)" (or repEta "ETA") evar))
	(ope (format "([ \t]*\\(?:1[ \t]*\\+[ \t]*%s\\|%s[ \t]*\\+[ \t]*1\\)[ \t]*)"
		     eta
		     eta
		     ))
	(pt (format "=[ \t]*\\(?:%s[ \t]*\\*[ \t]*[A-Z][A-Z0-9]*\\|[A-Z][A-Z0-9]*[ \t]*\\*[ \t]*%s\\)[ \t]*$" ope ope))
	(ettv (format "\\(?:%s[ \t]*\\*[ \t]*%%s\\|%%s[ \t]*\\*[ \t]*%s\\)" eta eta))
	(pt2 (format "=[ \t]*%s[ \t]*\\+[ \t]*\\1[ \t]*$" ettv))
	(pt3 (format "=[ \t]*\\([A-Z][A-Z0-9]*\\)[ \t]*\\+[ \t]*%s[ \t]*$" ettv))
	(lgvpe (format "\\(?:[A-Z][A-Z0-9]* *\\+ *%s\\|%s *\\+ *([A-Z][A-Z0-9]\\)" eta eta ))
	(lgv1pe (format "\\(?:1 *\\+ *D?EXP( *%s *)\\|D?EXP( *%s *) *\\+ *1\\)" lgvpe lgvpe))
	(lgv (format "= *D?EXP( *%s *) */ *( *%s *) *$" lgvpe lgv1pe))
	(lgv2 (format "= *1 */ *( *1 *\\+ *D?EXP( *%s *\\+ *LOG( *1 */ *[A-Z][A-Z0-9]+ *- *1 *) *) *) *$" eta))
	(num (if e1
		 (format "{%s}" e1)
	       ""))
        )
    (setq pt2 (format pt2 "\\([A-Z][A-Z0-9]*\\)" "\\([A-Z][A-Z0-9]*\\)"))
    (setq pt3 (format pt3 "\\1" "\\1"))
;    (mesage "``%s''\n%s" str pt3)
    (if (string-match (concat "\\*[ \t]*D?EXP([ \t]*" eta "[ \t]*)") str)
	(progn
	  (setq err (format "IIV_%s%s (Exp)" var num))
	  )
      (if (string-match (concat "D?EXP([ \t]*" eta "[ \t]*)[ \t]*\\*") str)
          (setq err (format "IIV_%s%s (Exp)" var num ))
        (if (or (string-match pt str) (or (string-match pt2 str) (string-match pt3 str)))
            (setq err (format "IIV_%s%s (Prop)" var num))
	  (if (or (string-match lgv str) (string-match lgv2 str))
	      (setq err (format "IIV_%s%s (Logit-Norm)" var num ))
	    (if (string-match (concat eta "[ \t]*\\+") str)
		(setq err (format "ETA_%s%s (Add)" var num))
	      (if (string-match (concat "\\+[ \t]*" eta) str)
		  (setq err (format "ETA_%s%s (Add)" var num))
		)
	      )
	    )
	  )
	)
      )
    (if (not (string-match "(Add)" err)) nil
      (if (string-match "D?EXP(.*\\+.*)" str)
	  (if (string-match "D?EXP(.*\\+ *IOV[0-9]+ *)" str)
	      (setq err (format "IIV_%s%s (Add)" var num))
	    (setq err (format "IOV_%s%s" var num))
	    )
	(setq err (format "IIV_%s%s (Add)" var num))
	)
      )
    (symbol-value 'err)
    )
  )

(defun esn-get-thetas (&optional thetaRep)
  "A subroutine that gets all the thetas from a file, along with their corresponding information.
func represents the formatting function for the tmp variable.
thetaRep represents the replacement text for theta.
Returns an alist with thetas associated with equation information
-1 -> maximum theta.
1 -> theta1 information
2 -> theta2 information
etc.
"
  ;; First get the file contents without comments and then all the thetas.
  ;; Maxtheta should be global.
  (let (
	(case-fold-search 't)
        (bufs "")
        (thetaa '())
        (thetac 1)
        (tmp nil)
	(maxtheta 0)
	(tvar (if thetaRep
		  (if (string= thetaRep "ETA")
		      (esn-get-variable-names "OME")
		    (if (string= thetaRep "EPS")
			(esn-get-variable-names "SIG")
		      (if (string= thetaRep "THETA")
			  (esn-get-variable-names "THE")
			(esn-get-variable-names "THE")
			)
		      )
		    )
		(esn-get-variable-names "THE")
		)
	      )
	(i 0)

        )
    (setq bufs (esn-rec esn-current-abbrev-records-regexp 't))
    (setq tvar (esn-get-variable-names "THE"))
    (with-temp-buffer
      (insert bufs)
      (goto-char (point-min))
      ;; Take out comments with THETA(#) in them.
      (while (re-search-forward (format ";.*\\<\\(%s([0-9]+)\\|%s\\).*$"  (or thetaRep "THETA")  (regexp-opt tvar)) nil t)
	(replace-match "")
	)
      ;; Take out space around the operators.
      (goto-char (point-min))
      (while (re-search-forward " +\\([=+-*/;]+\\) +" nil t)
	(replace-match (match-string 1)))
      ;; Take out extra spaces.
      (goto-char (point-min))
      (while (re-search-forward "  +" nil t)
	(replace-match " "))
      (goto-char (point-min))
      (while (re-search-forward "^ +" nil t)
	(replace-match ""))
      (goto-char (point-min))
      (while (re-search-forward " +$" nil t)
	(replace-match ""))
      (goto-char (point-min))
      (while (re-search-forward
	      (format "\\<\\(%s(%s)\\|%s\\)" (or thetaRep "THETA")
		      thetac (nth (+ thetac -1) tvar))
	      nil t)
	(beginning-of-line)
	(looking-at "^.*$")
	(setq tmp (match-string 0))
	(while (string-match "[ \t][ \t]+" tmp)
	  (setq tmp (replace-match "" nil nil tmp))
	  )
	(esn-add-to-alist 'thetaa (cons thetac tmp))
	(goto-char (point-min))
	(setq maxtheta thetac)
	(setq thetac (+ thetac 1))
	)
      )
    (esn-add-to-alist 'thetaa (cons -1 maxtheta))
    (symbol-value 'thetaa)
    )
  )
(defun esn-get-first-item-number (&optional the-rep)
  "This function gets the first ETA/EPS number in the $SIGMA
block by looking backward and counting the estimates that came
before. the-rep tells the record, assumes OME"
  (interactive)
  (save-excursion
    (let (
	  (case-fold-search 't)
	  (samecount 1)
	  (firsteta 1)
	  (skip nil)
	  (sig (or the-rep "OME"))
	  (sbegin nil)
	  (send nil)
	  (bufs "")
	  (sblock nil)
	  (same nil)
	  (send nil)
	  (ncount nil)
	  (setac 1)
	  (isfixed "")
	  )
      (re-search-backward (esn-reg-record-exp sig 't) nil t)
      (while (and (not skip) (re-search-backward (esn-reg-record-exp sig 't) nil 't))
	(forward-char (length (match-string 0)))
	(setq sbegin (point))
	(end-of-line)
	(re-search-forward (eval-when-compile (esn-reg-records 't 't)) nil t)
	(backward-char (length (match-string 0)))
	(setq send (point))
	(setq bufs (buffer-substring sbegin send))
	(goto-char sbegin)
	(beginning-of-line)
	(while (string-match ";.*$" bufs)
	  (setq bufs (replace-match "" nil nil bufs))
	  )
	(setq sblock nil)
	(setq same nil)
	(while (string-match "\\<BLOCK *\\(?:( *[0-9]+ *)\\)?" bufs)
	  (setq sblock 't)
	  (setq bufs (replace-match "" nil nil bufs))
	  )
	(while (string-match "\\<DIAGONAL([0-9]+)" bufs)
	  (setq bufs (replace-match "" nil nil bufs))
	  )
	(while (string-match "\\<SAME\\>" bufs)
	  (setq same 't)
	  (setq bufs (replace-match "" nil nil bufs))
	  )
	(if same
	    (setq samecount (+ samecount 1))
	  (setq ncount 0)
	  (while (string-match "([-0-9.EFIXDN, \t]+)" bufs)
	    (setq bufs (replace-match "" nil nil bufs))
	    (setq ncount (+ ncount 1))
	    )
	  (while (string-match "\\([-0-9.E]+\\|FIXED\\)" bufs)
	    (setq bufs (replace-match "" nil nil bufs))
	    (setq ncount (+ ncount 1))
	    )
	  (if sblock
	      (progn
		(setq setac 1)
		(while (> ncount
			  (/ (* setac (+ setac 1)) 2)
			  )
		  (setq setac (+ 1 setac))
		  )
		)
	    (setq setac ncount)
	    )
	  (setq firsteta (+ firsteta (* samecount setac)))
	  (setq samecount 1)
	  )
	)
      (symbol-value 'firsteta)
      )
    )
  )
(defun esn-update-comments-eta (len al &optional theRep fn n)
  (save-restriction
  (let* (
	 (case-fold-search 't)
	 (cp (point))
	 (thetalab '())
	 (sp (make-string len ? ))
	 (eol (concat " \n" sp))
	 (lp 't)
	 (max-line 0)
	 (tmp "")
	 (func (or fn 'esn-update-theta-label))
	 (blk nil)
	 (the (or theRep "OME"))
	 (i 0)
	 (cal 0)
	 (nlines 0)
	 (on nil)
	 (ntheta (cdr (assoc -1 al)))
	 (nrow 0)
	 (ncol 0)
	 (blockrow nil)
	 (point1 (point))
	 (point2 point1)
	 (maxlen '())
	 (maxcom 0)
	 (mincom -1)
	 (word "")
	 (line "")
	 (var "")
	 (ins "")
	 (num n)
         same
	 )
    (save-excursion
      (goto-char (point-min))
      (if (not (re-search-forward "\\<BLOCK *\\(?:( *[0-9]+ *)\\)?[ \n]*" nil t)) nil
	(setq blk 't)
	)
      )
    (save-excursion
      (goto-char (point-min))
      (setq same (re-search-forward "\\<SAME\\>" nil t))
      )
    (if (not blk)
	(esn-update-comments-theta len al theRep fn num)
      (if same
	  (progn
;	    (mesage "Block Same.")
	    (save-excursion
	      (widen)
	      (re-search-backward (eval-when-compile (esn-reg-record-exp "OME" 't)) nil t)
	      (if (not (re-search-backward (eval-when-compile (esn-reg-record-exp "OME" 't))))
		  (esn-error "Need a preceeding $OMEGA record.")
		(end-of-line)
		(esn-narrow-rec)
		(goto-char (point-min))
		(setq word "")
		(if (not (re-search-forward "\\<BLOCK(\\([0-9]+\\))" nil t))
		    (setq same "")
		  (setq same (match-string 1))
		  (end-of-line)
		  (while (re-search-forward ";;?\\(.*\\)" nil t)
		    (setq word (concat word "\n;;" (match-string 1)))
		    )
		  (setq word (substring word 1))
		  (while (string-match "{[0-9]+}" word)
		    (setq word (replace-match "{}" nil nil  word)))
		  (setq nrow num)

		  (while (string-match "{}" word)
		    (setq word (replace-match (format "{%s}" nrow) nil nil word))
		    (setq nrow (+ 1 nrow)))
		  )
		(widen)
		)
	      )
	    (esn-narrow-rec)
	    (goto-char (point-min))
	    ;; Fixing Block SAME items.
	    (if (string= same "") nil
	      (if (and (re-search-forward "\\<BLOCK(" nil t)
		       (looking-at "[0-9]+"))
		  (replace-match same))
	      )
	    (while (string-match "\\(.+\\)" word)
	      (setq line (match-string 1 word))
	      (setq word (replace-match "" nil nil word))
	      (end-of-line)
	      (skip-chars-forward "\n\t ")
	      (if (string-match "_\\([A-Za-z0-9.]*[^0-9{}]\\)\\([0-9]+\\)" line)
		  (setq line (replace-match (format "_\\1%s" (+ 1 (string-to-number (match-string 2 line)))) nil nil line))
		(if (string-match "_\\([A-Za-z0-9.]*\\)" line)
		    (setq line (replace-match (format "_\\1%s" "2") nil nil line)))
		)
	      (if (looking-at ";.*")
		  (progn
		    (skip-chars-forward "; \t")
		    (if (not (string-match "\\(IIV\\|IOV\\|ETA\\)_" line)) nil
		      (setq var (match-string 1 line))
		      (if (looking-at "\\(IIV\\|IOV\\|ETA\\)")
			  (if (string= var (match-string 1)) nil
			    (replace-match var)
			    (backward-char (length var))
			    )
			)
		      )
		    (if (not (re-search-forward "\\=\\(IIV\\|IOV\\|ETA\\)_" nil t)) nil
		      (if (not (string-match "_\\([A-Z0-9.]+\\)" line)) nil
			(setq var (match-string 1 line))
			(if (looking-at "\\([A-Z0-9.]*\\){")
			    (if (string= var (match-string 1)) nil
			      (replace-match (concat var "{" ))
			      (backward-char (+ 1 (length var)))
			      )
			  )
			)
		      (if (not (re-search-forward "\\=\\([A-Z0-9.]*\\)" nil t)) nil
			(if (not (string-match "\\({[0-9]+}\\)" line)) nil
			  (setq var (match-string 1 line))
			  (if (looking-at "\\({[0-9]+}\\)")
			      (if (string= var (match-string 1)) nil
				(replace-match var)
				(backward-char (length var))
				))
			  )
			)
		      (re-search-forward "\\={[0-9]+}" nil t)
		      (skip-chars-forward " \t")
		      (if (not (string-match "\\((\\(?:Exp\\|Prop\\|Logit-Norm\\|Add\\))\\)" line)) nil
			(setq var (match-string 1 line))
			(if (looking-at "\\((\\(?:Exp\\|Prop\\|Logit-Norm\\|Add\\))\\)")
			    (if (string= var (match-string 1)) nil
			      (replace-match var)
			      (backward-char (length var))
			      ))
			)
		      )
		    )
		(setq ins (concat ins eol line))
		)
	      )
	    (save-excursion
	      (goto-char (point-min))
	      (if (re-search-forward "\\<SAME\\>" nil t)
		  (replace-match (concat "SAME" ins) 't))
	      )
	)
	; End of line
	(save-excursion
	  (goto-char (point-max))
	  (if (not (re-search-backward " [0-9.]+\\(?: FIXED\\)?\\=" nil t)) nil
	    (esn-forward-w)
	    (insert " ")
	    )
	  )
;      (mesage "Spacing block.")
      (save-excursion
	(goto-char (point-min))
	(re-search-forward "\\=$[A-Z]*" nil t)
	(skip-chars-forward " \t\n")
	(while (not (eobp))
;	  (mesage "Begin block space.")
	  (skip-chars-forward " \t\n")
	  (setq blockrow (re-search-forward "\\=BLOCK *\\(( *[0-9]+ *)\\)?" nil t))
	  (re-search-forward "\\= *SAME" nil t)
	  (re-search-forward "\\= *;.*" nil t)
	  (if (not blockrow)
	      (skip-chars-forward " \t\n")
	    (skip-chars-forward " \t")
	    (if (not (looking-at "\n"))
		(insert eol))
	    (skip-chars-forward " \t\n")
	    )
;	  (mesage "Forward Word.")
	  (setq word (esn-forward-w))
	  (if (not (eobp))
	      (setq nlines (+ nlines 1))
	    )
;	  (mesage "Looking at space.")
	  (if (string-match "\\. *\\(\\(?: FIX\\(?:ED?\\)?\\)?\\)$" word)
	      (setq word (replace-match "\\1" nil nil word))
	    (if (string-match "^0+\\.\\([0-9]*[^0]\\) *\\(\\(?: FIX\\(?:ED?\\)?\\)?\\)$" word)
		(setq word (replace-match ".\\1\\2" nil nil word))
	      (if (string-match "\\.\\([0-9]*[^0]\\)0+ *\\(\\(?: FIX\\(?:ED?\\)?\\)?\\)$" word)
		  (setq word (replace-match ".\\1\\2" nil nil word))
		(if (string-match "\\.0+ *\\(\\(?: FIX\\(?:ED?\\)?\\)?\\)$" word)
		    (setq word (replace-match "\\1" nil nil word))))))
	  (setq word (length word))
;	  (mesage "Calculating the number of columns")
	  (setq nrow (/ (+ -1 (sqrt (+ 1 (* 8 nlines)))) 2))
	  (setq ncol nrow)
	  (setq ncol (floor ncol))
	  (setq ncol (- nlines (/ (* (+ ncol 1) ncol) 2)))
	  (setq ncol (ftruncate ncol))
	  (if (= (floor nrow) (ceiling nrow))
	      (setq ncol (- nlines (/ (* nrow  (- nrow 1)) 2))))
;	  (mesage "Saving column length.")
	  (if (not (assoc ncol maxlen))
	      (esn-add-to-alist 'maxlen (cons ncol 0)))
	  (if (> word (cdr (assoc ncol maxlen)))
	      (esn-add-to-alist 'maxlen (cons ncol word)))
	  (skip-chars-forward " \t")
;	  (mesage "Checking to see if we are at the end of the row.")
	  (if (not (= (floor nrow) (ceiling nrow))) nil
	    (if (< ntheta (- (+ nrow num) 1))
		(setq word "")
	      (setq word (number-to-string (- (+ nrow num) 1)) )
	      (if (string-match "\\.0+" word)
		  (setq word (replace-match "" nil nil word)))
	      (setq word (string-to-number word))
	      (if (not (assoc word al))
		  (setq word "")
		(setq line (cdr (assoc word al)))
		(setq var line)
		(if (string-match "\\(.*\\)=" var)
		    (setq var (match-string 1 var))
		  (setq var ""))
		(setq word (format "; %s" (esn-get-error-type-from-str line var nil word)))
		)
	      )
;	    (mesage "Fixing normal items")
	    ;; Fixing normal items
	    (if (string= "" word)
		(progn
		  (if (not (looking-at " *;"))
		      (insert eol))
		  )
	      (if (looking-at ";\\(.*\\)")
		  (progn
		    (if (looking-at "; *$")
			(replace-match word 't)
		      (if (string-match "IIV_\\([A-Z0-9]+\\)" word)
			  (save-excursion
			    (setq var (match-string 1 word))
			    (if (looking-at "; *IOV_\\([A-Z0-9]+\\)")
				(progn
				  (replace-match (concat "; IIV_" var) 't)
				  )
			      (if (and (re-search-forward "\\=; *IIV_" nil t)
				       (looking-at "\\([A-Z0-9]+\\)"))
				  (replace-match var 't))
			      )
			    )
			)
		      (if (string-match "{\\([0-9]+\\)}" word)
			  (save-excursion
			    (setq var (match-string 1 word))
			    (if (and (re-search-forward "\\=;.*?{[0-9]+}" nil t)
				     (re-search-backward "\\({[0-9]+}\\)\\=" nil t)
				     )
				(replace-match (concat "{" var "}") 't)
			      )
			    )
			)
		      (if (string-match "(\\(Exp\\|Prop\\|Logit-Norm\\|Add\\))" word)
			  (save-excursion
			    (setq var (match-string 1 word))
			    (if (and (re-search-forward "\\=;.*?(\\(Exp\\|Prop\\|Logit-Norm\\|Add\\))" nil t)
				     (re-search-backward "([^(]*?)" nil t))
				(replace-match (concat "(" var ")")))
			    )
			)
		      )

		    )
		)
;	      (mesage "Number of rows %s, word `%s'" nrow word)
	      (if (not (= nrow 0))
		  (if (not (and (not (string= "" word)) (looking-at (concat "\\(.*?\\)" (regexp-quote word)))))
		      (if (not (looking-at "\\(.*?\\)\\(;.*\\)"))
			  (save-excursion
			    (if (re-search-backward ";.*\\=" nil t) nil
			      (if (re-search-backward ";.*?\n[ \t\n]*\\=" nil t) nil
				(insert (concat word eol))
				)
			      )
			    )
			(insert (concat word eol))
			)
		    (save-excursion
		      (forward-char (length (match-string 1)))
		      (delete-char (length word))
		      )
		    (insert (concat word eol))
		    )
		)
	      )
	    )
	  )
;	(mesage "Done with while loop; Starting second while loop.")
	(setq nlines 0)
	(goto-char (point-min))
	(re-search-forward "\\=$[A-Z]*" nil t)
	(skip-chars-forward " \t\n")
	(while (not (eobp))
	  (skip-chars-forward " \t\n")
;	  (mesage "Getting Properties.")
	  (if (re-search-forward "\\=BLOCK *\\(( *[0-9]+ *)\\)?" nil t)
	      (if (and (re-search-backward "( *[0-9]+ *)\\=" nil t)
		       (looking-at "( *[0-9]+ *"))
		  (replace-match (format "(%s" (ceiling nrow)))
		(insert (format "(%s)" (ceiling nrow)))))
	  (re-search-forward "\\= *SAME" nil t)
	  (if (re-search-forward "\\= *;.*" nil t)
	      (save-excursion
		(beginning-of-line)
		(if (looking-at "\\(.*?\\)\\( *\\);")
		    (if (> (length (match-string 1)) maxcom)
			(setq maxcom (length (match-string 1))))
		  )
		)
	    )
;	  (mesage "Calculating number of lines, columms, etc.")
	  (if (not (eobp))
	      (setq nlines (+ nlines 1))
	    )
	  (setq nrow (/ (+ -1 (sqrt (+ 1 (* 8 nlines)))) 2))
	  (setq ncol nrow)
	  (setq ncol (floor ncol))
	  (setq ncol (- nlines (/ (* (+ ncol 1) ncol) 2)))
	  (setq ncol (ftruncate ncol))
	  (if (= (floor nrow) (ceiling nrow))
	      (setq ncol (- nlines (/ (* nrow  (- nrow 1)) 2))))
;	  (mesage "Going forward a word.")
	  (setq word (esn-forward-w))
	  (if (not (assoc ncol maxlen))
	      (esn-add-to-alist 'maxlen (cons ncol 0)))
;	  (mesage "Trying to fix word length through expansion(%s;%s;%s)" word ncol (assoc ncol maxlen))
	  (while (and
		  (string-match "^[0-9.]+ *\\(\\(?: FIX\\(?:ED?\\)?\\)?\\)$" word)
		  (< (length word) (cdr (assoc ncol maxlen))))
;	    (mesage "Going backward a word.")
	    (esn-backward-w)
	    (save-excursion
;	      (mesage "Looking at just a number?")
	      (if (re-search-forward "\\=[0-9]+ " nil t)
		  (progn
		    (backward-char 1)
		    (insert ".")
		    )
;		(mesage "Looking at a number with a period?")
		(if (re-search-forward "[0-9]+\\.[0-9]*" nil t)
		    (insert "0")
		  (if (looking-at "\\.")
		      (insert "0")
		    )
		  )
		)
	      )
;	    (mesage "Now go forward a word again.")
	    (setq word (esn-forward-w))
	    )
;	  (mesage "Trying to fix word length by contraction.")
	  (while (and (string-match "^[0-9.]+ *\\(\\(?: FIX\\(?:ED?\\)?\\)?\\)$" word) (> (length word) (cdr (assoc ncol maxlen))))
					; Reduction of word.
	      (esn-backward-w)
	      (save-excursion
		(if (re-search-forward "\\=[0-9]*\\.[0-9]*?0+" nil t)
		    (delete-backward-char 1)
		  (if (looking-at "0\\.")
		      (delete-char 1)
		    (if (re-search-forward "\\=[0-9]+\\. " nil t)
			(progn
			  (backward-char 1)
			  (delete-backward-char 1)
			  )
		      (if (re-search-forward "\\=[0-9.]+ \\{2,\\}F" nil t)
			  (progn
			    (re-search-backward "[0-9.] *F\\=")
			    (forward-char 1)
			    (if (looking-at " *")
				(replace-match " "))
			    )
;			(mesage "Can't figure out %s" word)
			(setq word "exit")
			)
		      )
		    )
		  )
		)
	      (if (string= word "exit") nil
		(setq word (esn-forward-w))
		)
	      )
	    )
;	(mesage "Removing trailing zeros and oter such phenomena.")
	  (goto-char (point-min))
	  (while (re-search-forward "\\(\\.[0]+\\) " nil t)
	    (replace-match (make-string (+ 1 (length (match-string 1))) ? ))
	    )
	  (goto-char (point-min))
	  (while (re-search-forward "\\(\\.[0-9]*[^0]\\)\\(0+\\) " nil t)
	    (replace-match (concat "\\1" (make-string (+ 1 (length (match-string 2))) ? ))))
	  (goto-char (point-min))
	  (while (re-search-forward "\\. " nil t)
	    (replace-match "  "))
	  (setq maxcom (+ maxcom 1))
	  (esn-align-to-max-line maxcom nil nil nil nil nil nil "\\<BLOCK.*?\\=" num)
	  )
;      (mesage "Bug Hack for double lines.")
     ; bug hack for double lines.
      (save-excursion
	(goto-char (point-min))
	(while (re-search-forward "\\([ \t]*\n[ \t]*\\)\\{2,\\}" nil t)
	  (replace-match eol)
	  )
	)
      )
    )
  )
  ))
(defun esn-update-comment-per-line (len &optional theRep num sp al)
  (let (
	(case-fold-search 't)
	(cp (point))
	(sp (make-string len ? ))
	(eol (concat " \n" sp))
	(lp 't)
	(max-line 0)
	(the (or theRep "THE"))
	(tmp "")
	(nlines 0)
	(ntheta (- (cdr (assoc -1 al)) (- num 1)))
	)
    (save-excursion
      (goto-char (point-min))
      (re-search-forward (eval-when-compile (format "\\=%s" (esn-reg-record-exp "THE" 't))) nil t)
      (skip-chars-forward " \t\n")
      (while (not (eobp))
	(esn-forward-w)
	(re-search-forward "\\= *;.*" nil t)
	(skip-chars-forward " \t\n")
	(setq nlines (+ nlines 1))
	)
      )
    (save-excursion
      (goto-char (point-max))
      (while lp
	(save-excursion
	  (if (re-search-backward (format "%[ \t]*\\=" (esn-reg-record-exp the)) nil t)
	      (setq lp nil))
	  )
	(if (not lp)
	    (end-of-line)
	  (if (not (re-search-backward "\\(?:;\\([^\n]*?\\)\\|SAME +\\|\\(?:BLOCK *\\|DIAGONAL\\)\\(?:( *[0-9]+ *)\\)?\\)\\=" nil t))
	      (progn
		(if (or (= nlines 0) (> nlines ntheta)) nil
		  (if (looking-at " +")
		      (replace-match (concat ";" tmp eol))
		    (insert (concat ";" tmp eol))
		    )
		  )
		(setq nlines (- nlines 1))
		(if (not (search-backward ";" nil t)) nil
		  (save-excursion
		    (beginning-of-line)
		    (if (looking-at "^\\(.*?\\) *;")
			(setq max-line (max (length (match-string 1)) max-line))
		      )
		    )
		  )
		(esn-backward-w)
		(skip-chars-backward " \n")
		)
	    (save-excursion
	      (beginning-of-line)
	      (if (looking-at "^\\(.*?\\) *;")
		  (setq max-line (max (length (match-string 1)) max-line))
		)
	      )
	    (esn-backward-w)
	    (skip-chars-backward " \n")
	    )
	  )
	)
      )
    (symbol-value 'max-line)
    )
  )
(defun esn-align-to-max-line (max-line &optional func curt cp al blk firstnum except num)
  "Aligns Comments."
  (let (
	(case-fold-search 't)
	(cur-len 0)
	(curt (or num 1))
	(nt nil)
	)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^\\(.*? *\\);" nil t)
	(setq nt nil)
	(save-excursion
	  (if (and except (re-search-backward except nil t))
	      (setq nt 't)))
	(if nt nil
					; Redo replace to maintain position.
	  (setq cur-len (- max-line (length (match-string 1))))
	  (if (= cur-len 0) nil
	    (if (> cur-len  0)
	      (progn
		(backward-char 1)
		(insert (make-string cur-len ? ))
		)
	      (backward-char 1)
	      (if (re-search-backward (format " \\{%s\\}\\=" (- 0 cur-len)) nil t)
		  (replace-match ""))
	      )
	    )
	  (skip-chars-forward "; ")
	  (if (not func) nil
	    (funcall func curt cp al blk firstnum)
	    (setq curt (+ 1 curt))
	    )
	  )
	)
      )
    )
  )
(defun esn-update-comments-theta (len al &optional theRep fn num)
  "Update the $THETA record comments while wrapping."
  (let* (
	 (case-fold-search 't)
	 (cp (point))
	 (thetalab '())
	 (sp (make-string len ? ))
	 (eol (concat " \n" sp))
	 (lp 't)
	 (max-line 0)
	 (cur-len 0)
	 (tmp "")
	 (curt (or num 1))
	 (firstnum num)
	 (func (or fn 'esn-update-theta-label))
	 (the (or theRep "THE"))
	 (blk nil)
	 )
    (setq max-line (esn-update-comment-per-line len the num sp al))
    (setq max-line (+ max-line 1))
    (esn-align-to-max-line max-line func curt cp al blk firstnum nil num)
    )
  )
(defun esn-update-eta-label (curt cp al blk firstnum)
  "Updates the theta label assuming that the current position to the end of the line is the theta label for theta curt. Blk defines if this is a block statment.  First Number tells the first eta in the block."
  (let (
	(case-fold-search 't)
	(sep esn-separator-between-eta-number-and-description)
	(cl nil)
	(pt nil)
	(e1 nil)
	(e2 nil)
	(linenum (- curt firstnum))
	(line "")
	(errtype "")
	(var1 "")
	(var2 "")
	)
    (if (not blk)
	(setq e1 curt)
      ; Figure out the eta combination.
      )
    (save-excursion
      (beginning-of-line)
      (setq pt (point))
      (goto-char cp)
      (if (not (re-search-backward ";.*\\=" nil t)) nil
	(beginning-of-line)
	(if (= (point) pt)
	    (setq cl 't)
	  )
	)
      )
    ;
    (while (string-match " " sep)
      (setq sep (replace-match "" nil nil sep)))
    (if (not e2)
	(progn
	  (setq line (cdr (assoc e1 al)))
	  (setq var1 line)
	  (if line
	      (progn
		(if (string-match "\\(.*\\)=" var1)
		    (setq var1 (match-string 1 var1))
		  (setq var1 ""))
		(setq errtype (esn-get-error-type-from-str line var1 nil e1))
		)
	    (setq line "")
	    (setq var1 "")
	    (setq errtype "ETA not found")
	    )
	  (if esn-add-eta-number-to-labels
	      (if (looking-at " *\\([0-9]+\\)")
		  (if (not (string= (match-string 1) (number-to-string curt)))
		      (replace-match (format " %s" curt))
		    (forward-char (+ 1 (length (match-string 1))))
		    )
		(insert (format " %s" curt))
		(if (looking-at (format "\\( *%s *\\)+" sep) ) nil
		  (insert (format " %s " sep))
		  )
		)
	    (if (looking-at (format "\\([0-9]+\\) *%s *" sep))
		(replace-match "")
	      )
	    )
	  (skip-chars-forward (format " %s" sep))
	  (skip-chars-backward " ")
	  (if (looking-at " *\n")
	      (insert (concat " " errtype))
	    )
	  )
      ; BLOCKed statment.
      )
    )
  )
(defun esn-update-theta-label (curt cp al blk firstnum)
  "Updates the theta label assuming that the current position to the end of the line is the theta label for theta curt."
  (let* (
	 (case-fold-search 't)
	(sep esn-separator-between-variable-and-description)
	(tmp "")
	(line (cdr (assoc curt al)))
	(prefix line)
	(comment line)
	(cl nil)
	(pt nil)
	)
    (save-excursion
      (beginning-of-line)
      (setq pt (point))
      (goto-char cp)
      (if (not (re-search-backward ";.*\\=" nil t)) nil
	(beginning-of-line)
	(if (= (point) pt)
	    (setq cl 't)
	  )
	)
      )
    (if (not line)
	(progn
	  (setq prefix "")
	  (setq comment "")
	  )
      (if (string-match "\\(.*\\)=" prefix)
	  (setq prefix (match-string 1 prefix))
	(setq prefix ""))
      (if (string-match ";\\(.*\\)" comment)
	  (setq comment (match-string 1 comment))
	(setq comment ""))
      )
    (if (string= prefix "") nil
      (if (not esn-display-variable-name-in-labels)
	(progn
	  )
	(if (and esn-take-out-tv-theta (string-match "^TV" prefix))
	    (setq prefix (replace-match "" nil nil prefix)))
	(if (re-search-forward (format  "\\=.*?\\([({\\[;%s]\\)" sep) nil t)
	    (backward-char 1)
	  (if (looking-at " *$")
	      (insert prefix)
	    )
	  )
	)
      (if (not esn-add-theta-number-to-labels) nil
	  (if (looking-at " *\\([({\\[;]\\) *\\([0-9]+\\) *\\([;})\\]]?\\)")
	      (replace-match (concat (match-string 1) (number-to-string curt) (match-string 3)))
	    (insert (concat "{" (number-to-string curt) "}"))
	    )
	)
      (skip-chars-backward " ")
      ;; Ok now add the comment, if nothing is there."
      (if (string= comment "") nil
	(if (looking-at " *$")
	    (replace-match (concat " " sep  " " comment))
	)
      )
      (if (not (or (looking-at " *$") (looking-at (concat " *" sep))))
	  (if (looking-at " *")
	      (replace-match (concat " " sep " "))
	    )
	)
      )
    )
  )


(provide 'esn-space-theta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; esn-space-theta.el ends here
